---
layout: post
title: "Android開発 - RxJavaを使ったネットワークリクエスト：トークンの再取得と再実行"
date: 2021-02-19 21:37:48 +0800
image: cover/ea-website-rxjava-cover-photo-new-1.png
tags: [Android]
categories: Android實作
permalink: /android-kt-rxjava
excerpt: "この記事では、RxJavaを使用してトークンの再取得とネットワークリクエストの再実行を実現する方法を紹介します。これにより、アプリケーションのユーザー体験が向上します。"
---

<div class="c-border-main-title-2">前書き</div>
皆さん、こんにちは！<br>
久しぶりの投稿です。<br>
今日は、RxJavaを使ったネットワークリクエスト（例：OkHttp + Retrofit）で、<br>
トークンの再取得と同じ接続の再リクエストを解決する方法を共有します。<br>
この問題は、多くの接続が必要なアプリでよく見られます。<br>
サーバーにリクエストを送る際、<br>
ユーザーの正当性を確保するために、<br>
通常はトークン機構を使用してログインやAPIアクセスの権限を検証します。<br>
トークンには有効期限があり、<br>
良好なユーザー体験を提供するために、<br>
特定のネットワークリクエスト中にトークンが期限切れになったことに気づかない場合でも、<br>
より完全なプロセスを実現する必要があります。<br>

<div class="c-border-content-title-4">関連知識</div><br>
この記事では、以下の関連知識を使用しますが、<br>
主にトークンの再取得とネットワーク接続の再接続のプロセスを共有することに焦点を当てているため、<br>
詳細には触れません。興味がある方は調べるか、私にメッセージを送ってください：

* ジェネリック
* Kotlin拡張
* Kotlin関数型
* RxJava
* Retrofit
* Okhttp

<div class="c-border-main-title-2">考え方</div>

<br>
通常、トークン機構を持つAPIリクエストをアプリケーションに統合する際、<br>
適切な処理を行わないと、実行フローは以下のようになる可能性があります：

```
アプリネットワークリクエスト -> トークン期限切れ -> サーバーがアクセス期限切れを返す -> アプリがエラーに応じた処理を行う
```
<br>

このような場合、<br>
エラー処理を行っているにもかかわらず、<br>
トークンが期限切れになるたびに、<br>
エラー処理（例：ユーザーにトークンが期限切れであることを通知）が発生します。<br>
一度や二度なら偶発的な状況と見なされるかもしれませんが、<br>
何度も繰り返されると、<br>
ユーザーはアプリに問題があると感じ、<br>
スムーズに実行できないと考え、<br>
ユーザー体験が低下し、<br>さらなる問題を引き起こす可能性があります。<br><br>

したがって、<br>
以下のようなフローを実現し、<br>
トークンを再取得した後、<br>
元のネットワーク接続を再実行できるようにしたいと考えています：<br>

```
アプリネットワークリクエスト -> トークン期限切れ -> サーバーがアクセス期限切れを返す -> トークン再取得プロセスを実行 -> アプリが同じネットワークリクエストを再実行
```
<br>

<div class="c-border-main-title-2">実際の開発</div>
この記事では、主にRxJavaのオペレーターを使用してネットワークリクエストを行い、<br>
RetrofitをラップしてOkHttpを適用してネットワークAPIをリクエストする方法を共有します：<br>

<script src="https://gist.github.com/waitzShigoto/5724788a6a2efa973eb31b497ffb65df.js"></script><br>

RxJavaを使用してネットワークリクエストを操作する場合、<br>
通常はRxオペレーターを使用して制御します。<br>
ここでは、<br>
Observableを使用しています。上記のコードでは：<br>

```
repo.getPaymentData(paymentRequest)
```

返される結果はObservableです。<br>
以前述べた方法に従うと、<br>
最初の状況が発生する可能性があります。<br>
つまり、ネットワークリクエスト後にトークンが無効になり、<br>
エラー処理のみが行われ、トークンが再取得されても、<br>
APIが再リクエストされません。<br>

この問題を解決するために、<br>
RxJavaを使用して実行中にトークンを再取得し、<br>
新しいトークンを使用して元のAPIに再接続する方法を研究し始めました。<br>
そのために、<br>
この機能を実現するためのKotlinの拡張関数（extension function）を作成しました：<br>

<script src="https://gist.github.com/waitzShigoto/889f4e67cf5edae25cffc006a25032dd.js"></script>

<div class="c-border-content-title-4">コード解説</div><br>
**1. この拡張機能を実際に適用すると、次のようになります：**<br>

<script src="https://gist.github.com/waitzShigoto/8ef1124c7d67d02b7e3024fc56735bc8.js"></script>
使用は非常に簡単で、<br>
トークンを再取得する必要がある場所にこの拡張関数を追加するだけです。<br>
トークンを再取得する必要がない場所では、従来の方法で実行を続けます。<br>
この拡張関数の応用は非常に柔軟で、<br>
以下のコードを追加するだけです：<br>

```
.retryNoKeyWhenError(resetRequest = {                       
     repo.getPaymentData(resetRequestToken(paymentRequest))})
```

**2. 拡張した関数を個別に見てみましょう**

私はflapmapを使用してObserable<T>内のデータを解析しました。<br>
また、これは接続リクエストであるため、通常サーバーは固定の形式で結果を返します。<br>
ここでリクエスト結果の状態を解析し、<br>
成功の場合は元のレスポンス全体をobserverに返します。<br>
エラーの場合は、実際のニーズに応じて処理方法を記述します。例えば：<br>

次のような状況に遭遇した場合<br>
（ここでは独自に定義したenumクラスで、主に署名やトークンの期限切れの状況です。ここは自由に定義できます）<br>

 ```
 State.FAIL_SIGNATURE_ERROR.value
 State.FAIL_SIGNATURE_EXPIRED.value
 State.FAIL_KEY_TOKEN_EXPIRED.value
 ```
 トークンを再取得するAPIを実行し、必要なデータを保存した後、対応するデータを返し、元のエラー状況をobserverに返します。


 **3. この時点で、retryWhenを使用します**

 前にエラー状況を返したため、<br>
 retryWhenがトリガーされます。<br>
 ここでは、retry回数のObserableと何秒後に再試行するかを定義しました。<br>
 前のinputのIntに基づいて、失敗した場合に何秒後に再試行するかを判断します。<br>

そして最も重要なのは、前に使用した関数タイプが、<br>
ここで重要な役割を果たすことです。なぜなら、リクエストが失敗した後に、<br>
実行する予定のメソッドがここに記述されるからです：<br>
```
resetRequest.invoke().delay(delayInSeconds, TimeUnit.SECONDS)
```
<br>

ここで定義した拡張の戻り値の型はObservable < T >です。<br>
そのため、元のサブスクリプションに再接続できるので、非常に便利だと思います。<br>
参考にしてください。<br>

最後に、<br>
他の状況に応じて特定のエラー定数と処理フローを定義し、<br>
この拡張関数に対応する処理ロジックを追加することができます。<br>
どんな状況に遭遇しても、<br>
事前に対応するエラー定数と処理フローを定義しておけば、<br>
この拡張関数は対応する処理を実行するのに役立ちます。<br>
この関数を自分のニーズに合わせて拡張し、<br>
アプリケーションシナリオにより適応させることができます。<br>
